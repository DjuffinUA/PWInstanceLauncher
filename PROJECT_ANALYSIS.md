# Аналіз коду і доробки відповідно до Етапу 5

## 1) Аналіз перед змінами
На момент перевірки Етапи 1–4 були реалізовані функціонально, але для Етапу 5 бракувало:
- моніторингу життєвого циклу запущених процесів;
- очищення runtime-стану після завершення процесу;
- індикації поточного стану персонажа (Running/Offline) в UI;
- гарантії, що після закриття вікна/процесу персонаж доступний до коректного перезапуску без «завислого» стану.

---

## 2) Що внесено для Етапу 5

### MainViewModel
- Додано runtime-реєстр процесів: `Dictionary<string, int> _runningProcessByLogin`.
- Додано `DispatcherTimer` (3 сек) для регулярної перевірки стану процесів.
- Додано `InitializeRuntimeState()`:
  - при старті VM робиться первинна синхронізація «персонаж -> процес»;
  - встановлюється стартовий статус `Offline/Running`.
- Додано `MonitorRunningProcesses()`:
  - очищує реєстр від завершених PID;
  - оновлює статус персонажів на `Offline`;
  - знаходить уже запущені процеси, що не були в реєстрі, і ставить `Running`.
- Додано `RegisterRunningProcess(...)`, `SetStatus(...)`, `SetStatusByLogin(...)` для спрощення коду.
- При запуску нового процесу (`LaunchNewCharacter`) одразу реєструється PID та статус `Running`.
- При фокусі існуючого процесу також оновлюється runtime-стан.
- При видаленні профілю cleanup runtime-мапи виконується одразу.

### CharacterProfile
- Додано `RuntimeStatus` (`Offline` за замовчуванням) для UI-індикації.
- Додано `INotifyPropertyChanged` для реактивного оновлення UI без перезавантаження колекції.
- `RuntimeStatus` помічено `[JsonIgnore]`, щоб runtime-стан не потрапляв у `config.json`.

### MainWindow.xaml
- Додано вивід статусу персонажа (`RuntimeStatus`) поруч із кнопками керування.
- Оновлено layout картки персонажа для читабельного відображення статусу.

---

## 3) Повторний аналіз логіки після змін

### Етап 5 — перевірка критеріїв
- **Таймер моніторингу процесів:** реалізовано (`DispatcherTimer`).
- **Якщо вікно/процес закрито — cleanup стану:** реалізовано через `MonitorRunningProcesses()` + `IsProcessAlive`.
- **Можливість перезапуску:** забезпечено, бо завершені процеси видаляються з runtime-мапи і профіль повертається в `Offline`.

### Додаткова перевірка логіки
- Етапи 1–4 не зламані:
  - валідація `GamePath` і профілю лишилась;
  - duplicate-check і launch pipeline лишились;
  - desktop-flow (`SeparateDesktop` / `CurrentDesktop`) лишився та працює разом із новим runtime-monitoring.

---

## 4) Поточна готовність по етапах
- **Етап 1:** закрито.
- **Етап 2:** закрито.
- **Етап 3:** закрито (з технічним ризиком WMI залежності для читання command line).
- **Етап 4:** закрито функціонально.
- **Етап 5:** закрито функціонально (моніторинг + cleanup + можливість перезапуску + статуси).

---

## 5) Залишкові технічні ризики
- Визначення процесу по логіну залежить від доступності WMI `Win32_Process.CommandLine`.
- Desktop-mapping по логіну зберігається тільки в оперативній пам'яті поточного запуску застосунку.
